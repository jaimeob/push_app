{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\n\n\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries; // TODO: define A/B testing values for retry behaviors.\n\n    /** Repeat the API call as long as necessary. */\n\n    function repeat() {\n      timeoutId = null;\n\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      retries++;\n      const toCall = timeout_1.addTimeoutArg(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n\n        canceller = null;\n\n        if (retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat();\n          }, toSleep);\n        }\n      });\n\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n\n    };\n  };\n}\n\nexports.retryable = retryable;","map":{"version":3,"mappings":"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","names":["retryable","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","error","googleError_1","code","status_1","DEADLINE_EXCEEDED","toCall","timeout_1","err","response","next","rawResponse","retryCodes","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED","exports"],"sources":["../../../src/normalCalls/retries.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}