{"ast":null,"code":"'use strict';\n\nconst {\n  Writable\n} = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst PartStream = require('./PartStream');\n\nconst HeaderParser = require('./HeaderParser');\n\nconst DASH = 45;\nconst B_ONEDASH = Buffer.from('-');\nconst B_CRLF = Buffer.from('\\r\\n');\n\nconst EMPTY_FN = () => {};\n\nclass Dicer extends Writable {\n  constructor(cfg) {\n    super(cfg);\n    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== 'string') throw new TypeError('Boundary required');\n    if (typeof cfg.boundary === 'string') this.setBoundary(cfg.boundary);else this._bparser = undefined;\n    this._headerFirst = cfg.headerFirst;\n    this._dashes = 0;\n    this._parts = 0;\n    this._finished = false;\n    this._realFinish = false;\n    this._isPreamble = true;\n    this._justMatched = false;\n    this._firstWrite = true;\n    this._inHeader = true;\n    this._part = undefined;\n    this._cb = undefined;\n    this._ignoreData = false;\n    this._partOpts = typeof cfg.partHwm === 'number' ? {\n      highWaterMark: cfg.partHwm\n    } : {};\n    this._pause = false;\n    this._hparser = new HeaderParser(cfg);\n\n    this._hparser.on('header', header => {\n      this._inHeader = false;\n\n      this._part.emit('header', header);\n    });\n\n    this._hparser.on('error', err => {\n      if (this._part && !this._ignoreData) {\n        this._part.emit('error', err);\n\n        this._part.push(null);\n      }\n    });\n  }\n\n  emit(ev) {\n    if (ev !== 'finish' || this._realFinish) {\n      Writable.prototype.emit.apply(this, arguments);\n      return;\n    }\n\n    if (this._finished) return;\n    process.nextTick(() => {\n      this.emit('error', new Error('Unexpected end of multipart data'));\n\n      if (this._part && !this._ignoreData) {\n        const type = this._isPreamble ? 'Preamble' : 'Part';\n\n        this._part.emit('error', new Error(`${type} terminated early due to ` + 'unexpected end of multipart data'));\n\n        this._part.push(null);\n\n        process.nextTick(() => {\n          this._realFinish = true;\n          this.emit('finish');\n          this._realFinish = false;\n        });\n        return;\n      }\n\n      this._realFinish = true;\n      this.emit('finish');\n      this._realFinish = false;\n    });\n  }\n\n  _write(data, encoding, cb) {\n    // Ignore unexpected data (e.g. extra trailer data after finished)\n    if (!this._hparser && !this._bparser) return cb();\n\n    if (this._headerFirst && this._isPreamble) {\n      if (!this._part) {\n        this._part = new PartStream(this._partOpts);\n        if (this._events.preamble) this.emit('preamble', this._part);else ignore(this);\n      }\n\n      const r = this._hparser.push(data);\n\n      if (!this._inHeader && r !== undefined && r < data.length) data = data.slice(r);else return cb();\n    } // Allows for \"easier\" testing\n\n\n    if (this._firstWrite) {\n      this._bparser.push(B_CRLF);\n\n      this._firstWrite = false;\n    }\n\n    this._bparser.push(data);\n\n    if (this._pause) this._cb = cb;else cb();\n  }\n\n  reset() {\n    this._part = undefined;\n    this._bparser = undefined;\n    this._hparser = undefined;\n  }\n\n  setBoundary(boundary) {\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, onInfo.bind(this));\n  }\n\n}\n\nfunction onInfo(isMatch, data, start, end) {\n  let buf;\n  let i = 0;\n  let r;\n  let ev;\n  let shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && start + i < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes) buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n\n    if (this._dashes === 2) {\n      if (start + i < end && this._events.trailer) this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true; // No more parts will be added\n\n      if (this._parts === 0) {\n        this._realFinish = true;\n        this.emit('finish');\n        this._realFinish = false;\n      }\n    }\n\n    if (this._dashes) return;\n  }\n\n  if (this._justMatched) this._justMatched = false;\n\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n\n    this._part._read = n => {\n      unpause(this);\n    };\n\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev]) this.emit(ev, this._part);else ignore(this);\n    if (!this._isPreamble) this._inHeader = true;\n  }\n\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf) shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore) this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf) this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end) onInfo.call(this, false, data, start + r, end);\n    }\n  }\n\n  if (isMatch) {\n    this._hparser.reset();\n\n    if (this._isPreamble) {\n      this._isPreamble = false;\n    } else {\n      ++this._parts;\n\n      this._part.on('end', () => {\n        if (--this._parts === 0) {\n          if (this._finished) {\n            this._realFinish = true;\n            this.emit('finish');\n            this._realFinish = false;\n          } else {\n            unpause(this);\n          }\n        }\n      });\n    }\n\n    this._part.push(null);\n\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n}\n\nfunction ignore(self) {\n  if (self._part && !self._ignoreData) {\n    self._ignoreData = true;\n\n    self._part.on('error', EMPTY_FN); // We must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n\n\n    self._part.resume();\n  }\n}\n\nfunction unpause(self) {\n  if (!self._pause) return;\n  self._pause = false;\n\n  if (self._cb) {\n    const cb = self._cb;\n    self._cb = undefined;\n    cb();\n  }\n}\n\nmodule.exports = Dicer;","map":{"version":3,"sources":["/Users/jaimeojeda/Documents/firebase/push_app/node_modules/dicer/lib/Dicer.js"],"names":["Writable","require","StreamSearch","PartStream","HeaderParser","DASH","B_ONEDASH","Buffer","from","B_CRLF","EMPTY_FN","Dicer","constructor","cfg","headerFirst","boundary","TypeError","setBoundary","_bparser","undefined","_headerFirst","_dashes","_parts","_finished","_realFinish","_isPreamble","_justMatched","_firstWrite","_inHeader","_part","_cb","_ignoreData","_partOpts","partHwm","highWaterMark","_pause","_hparser","on","header","emit","err","push","ev","prototype","apply","arguments","process","nextTick","Error","type","_write","data","encoding","cb","_events","preamble","ignore","r","length","slice","reset","onInfo","bind","isMatch","start","end","buf","i","shouldWriteMore","trailer","_read","n","unpause","call","self","resume","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Writable } = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst PartStream = require('./PartStream');\nconst HeaderParser = require('./HeaderParser');\n\nconst DASH = 45;\nconst B_ONEDASH = Buffer.from('-');\nconst B_CRLF = Buffer.from('\\r\\n');\nconst EMPTY_FN = () => {};\n\nclass Dicer extends Writable {\n  constructor(cfg) {\n    super(cfg);\n\n    if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string'))\n      throw new TypeError('Boundary required');\n\n    if (typeof cfg.boundary === 'string')\n      this.setBoundary(cfg.boundary);\n    else\n      this._bparser = undefined;\n\n    this._headerFirst = cfg.headerFirst;\n\n    this._dashes = 0;\n    this._parts = 0;\n    this._finished = false;\n    this._realFinish = false;\n    this._isPreamble = true;\n    this._justMatched = false;\n    this._firstWrite = true;\n    this._inHeader = true;\n    this._part = undefined;\n    this._cb = undefined;\n    this._ignoreData = false;\n    this._partOpts = (typeof cfg.partHwm === 'number'\n                      ? { highWaterMark: cfg.partHwm }\n                      : {});\n    this._pause = false;\n\n    this._hparser = new HeaderParser(cfg);\n    this._hparser.on('header', (header) => {\n      this._inHeader = false;\n      this._part.emit('header', header);\n    });\n    this._hparser.on('error', (err) => {\n      if (this._part && !this._ignoreData) {\n        this._part.emit('error', err);\n        this._part.push(null);\n      }\n    });\n  }\n\n  emit(ev) {\n    if (ev !== 'finish' || this._realFinish) {\n      Writable.prototype.emit.apply(this, arguments);\n      return;\n    }\n\n    if (this._finished)\n      return;\n\n    process.nextTick(() => {\n      this.emit('error', new Error('Unexpected end of multipart data'));\n\n      if (this._part && !this._ignoreData) {\n        const type = (this._isPreamble ? 'Preamble' : 'Part');\n        this._part.emit(\n          'error',\n          new Error(`${type} terminated early due to `\n                    + 'unexpected end of multipart data')\n        );\n        this._part.push(null);\n        process.nextTick(() => {\n          this._realFinish = true;\n          this.emit('finish');\n          this._realFinish = false;\n        });\n        return;\n      }\n\n      this._realFinish = true;\n      this.emit('finish');\n      this._realFinish = false;\n    });\n  }\n\n  _write(data, encoding, cb) {\n    // Ignore unexpected data (e.g. extra trailer data after finished)\n    if (!this._hparser && !this._bparser)\n      return cb();\n\n    if (this._headerFirst && this._isPreamble) {\n      if (!this._part) {\n        this._part = new PartStream(this._partOpts);\n        if (this._events.preamble)\n          this.emit('preamble', this._part);\n        else\n          ignore(this);\n      }\n      const r = this._hparser.push(data);\n      if (!this._inHeader && r !== undefined && r < data.length)\n        data = data.slice(r);\n      else\n        return cb();\n    }\n\n    // Allows for \"easier\" testing\n    if (this._firstWrite) {\n      this._bparser.push(B_CRLF);\n      this._firstWrite = false;\n    }\n\n    this._bparser.push(data);\n\n    if (this._pause)\n      this._cb = cb;\n    else\n      cb();\n  }\n\n  reset() {\n    this._part = undefined;\n    this._bparser = undefined;\n    this._hparser = undefined;\n  }\n\n  setBoundary(boundary) {\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, onInfo.bind(this));\n  }\n}\n\nfunction onInfo(isMatch, data, start, end) {\n  let buf;\n  let i = 0;\n  let r;\n  let ev;\n  let shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && (start + i) < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes)\n          buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n    if (this._dashes === 2) {\n      if ((start + i) < end && this._events.trailer)\n        this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true;\n      // No more parts will be added\n      if (this._parts === 0) {\n        this._realFinish = true;\n        this.emit('finish');\n        this._realFinish = false;\n      }\n    }\n    if (this._dashes)\n      return;\n  }\n  if (this._justMatched)\n    this._justMatched = false;\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n    this._part._read = (n) => {\n      unpause(this);\n    };\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev])\n      this.emit(ev, this._part);\n    else\n      ignore(this);\n    if (!this._isPreamble)\n      this._inHeader = true;\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf)\n        shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore)\n        this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf)\n        this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end)\n        onInfo.call(this, false, data, start + r, end);\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset();\n    if (this._isPreamble) {\n      this._isPreamble = false;\n    } else {\n      ++this._parts;\n      this._part.on('end', () => {\n        if (--this._parts === 0) {\n          if (this._finished) {\n            this._realFinish = true;\n            this.emit('finish');\n            this._realFinish = false;\n          } else {\n            unpause(this);\n          }\n        }\n      });\n    }\n    this._part.push(null);\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n}\n\nfunction ignore(self) {\n  if (self._part && !self._ignoreData) {\n    self._ignoreData = true;\n    self._part.on('error', EMPTY_FN);\n    // We must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    self._part.resume();\n  }\n}\n\nfunction unpause(self) {\n  if (!self._pause)\n    return;\n\n  self._pause = false;\n  if (self._cb) {\n    const cb = self._cb;\n    self._cb = undefined;\n    cb();\n  }\n}\n\nmodule.exports = Dicer;\n"]},"metadata":{},"sourceType":"script"}