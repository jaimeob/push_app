{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst util_1 = require(\"./util\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n  const fullyQualifiedTypeName = typeof type === 'string' ? type : (0, util_1.getFullyQualifiedTypeName)(type);\n\n  if (typeof type !== 'string' && 'values' in type) {\n    // type is an Enum\n    if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      return 'NULL_VALUE';\n    }\n\n    return (0, enum_1.resolveEnumValueToString)(type, json);\n  }\n\n  if (typeof type !== 'string') {\n    type.resolveAll();\n  }\n\n  if (typeof type === 'string') {\n    return json;\n  } // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  // Types that can have meaningful \"null\" value\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueFromProto3JSON)(json);\n  }\n\n  if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n    if (json !== null && typeof json === 'object' || Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for ${fullyQualifiedTypeName} expects a string, a number, or a boolean, but got ${typeof json}`);\n    }\n\n    return (0, wrappers_1.wrapperFromProto3JSON)(fullyQualifiedTypeName, json);\n  }\n\n  if (json === null) {\n    return null;\n  } // Types that cannot be \"null\"\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyFromProto3JSON)(type.root, json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n    if (typeof json !== 'object') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got ${typeof json}`);\n    }\n\n    if (Array.isArray(json)) {\n      throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n    }\n\n    return (0, value_1.googleProtobufStructFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n    if (!Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got ${typeof json}`);\n    }\n\n    return (0, value_1.googleProtobufListValueFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got ${typeof json}`);\n    }\n\n    return (0, duration_1.googleProtobufDurationFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got ${typeof json}`);\n    }\n\n    return (0, timestamp_1.googleProtobufTimestampFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got ${typeof json}`);\n    }\n\n    return (0, fieldmask_1.googleProtobufFieldMaskFromProto3JSON)(json);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(json)) {\n    const field = type.fields[key];\n\n    if (!field) {\n      continue;\n    }\n\n    const resolvedType = field.resolvedType;\n    const fieldType = field.type;\n\n    if (field.repeated) {\n      if (!Array.isArray(value)) {\n        throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field ${key}`);\n      }\n\n      result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n    } else if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n      }\n\n      result[key] = map;\n    } else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'string') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bool') {\n      if (typeof value !== 'boolean') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bytes') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = (0, bytes_1.bytesFromProto3JSON)(value);\n    } else {\n      // Message type\n      assert(resolvedType, `Expected to be able to resolve type for field ${field.name}`);\n      const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n      result[key] = deserializedValue;\n    }\n  }\n\n  return result;\n}\n\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\n\nfunction fromProto3JSON(type, json) {\n  const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n\n  if (internalRepr === null) {\n    return null;\n  } // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n\n\n  assert(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not ${json}`);\n  return type.fromObject(internalRepr);\n}\n\nexports.fromProto3JSON = fromProto3JSON;","map":{"version":3,"mappings":"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","names":["fromProto3JSONToInternalRepresentation","type","json","fullyQualifiedTypeName","resolveAll","util_1","has","Array","isArray","Error","root","result","key","value","Object","entries","field","fields","resolvedType","fieldType","repeated","map","element","mapKey","mapValue","match","assert","name","deserializedValue","exports","fromProto3JSON","internalRepr","fromObject"],"sources":["../../typescript/src/fromproto3json.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}