{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst util_1 = require(\"./util\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nconst id = x => {\n  return x;\n};\n\nfunction toProto3JSON(obj) {\n  const objType = obj.$type;\n\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n\n  objType.resolveAll();\n  const typeName = (0, util_1.getFullyQualifiedTypeName)(objType); // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n\n  if (typeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Struct') {\n    return (0, value_1.googleProtobufStructToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.ListValue') {\n    return (0, value_1.googleProtobufListValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Duration') {\n    return (0, duration_1.googleProtobufDurationToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Timestamp') {\n    return (0, timestamp_1.googleProtobufTimestampToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.FieldMask') {\n    return (0, fieldmask_1.googleProtobufFieldMaskToProto3JSON)(obj);\n  }\n\n  if (util_1.wrapperTypes.has(typeName)) {\n    return (0, wrappers_1.wrapperToProto3JSON)(obj);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const field = objType.fields[key];\n    const fieldResolvedType = field.resolvedType;\n    const fieldFullyQualifiedTypeName = fieldResolvedType ? (0, util_1.getFullyQualifiedTypeName)(fieldResolvedType) : null;\n\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length === 0) {\n        // ignore repeated fields with no values\n        continue;\n      } // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n\n\n      result[key] = value.map(fieldResolvedType ? element => {\n        return toProto3JSON(element);\n      } : id);\n      continue;\n    }\n\n    if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue) : mapValue;\n      }\n\n      result[key] = map;\n      continue;\n    }\n\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      result[key] = (0, enum_1.resolveEnumValueToString)(fieldResolvedType, value);\n      continue;\n    }\n\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value);\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      if (typeof value === 'number' && !Number.isFinite(value)) {\n        result[key] = value.toString();\n        continue;\n      }\n\n      result[key] = value;\n      continue;\n    }\n\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = (0, bytes_1.bytesToProto3JSON)(value);\n      continue;\n    } // The remaining case is Long, everything else is an internal error\n\n\n    assert(value.constructor.name === 'Long', `toProto3JSON: don't know how to convert field ${key} with value ${value}`);\n    result[key] = value.toString();\n    continue;\n  }\n\n  return result;\n}\n\nexports.toProto3JSON = toProto3JSON;","map":{"version":3,"mappings":"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","names":["id","x","toProto3JSON","obj","objType","$type","Error","resolveAll","typeName","util_1","has","result","key","value","Object","entries","field","fields","fieldResolvedType","resolvedType","fieldFullyQualifiedTypeName","Array","isArray","length","map","element","mapKey","mapValue","Number","isFinite","toString","Buffer","isBuffer","Uint8Array","assert","constructor","name","exports"],"sources":["../../typescript/src/toproto3json.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}