{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamArrayParser = void 0;\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst stream_1 = require(\"stream\");\n\nconst fallbackRest_1 = require(\"./fallbackRest\");\n\nconst featureDetection_1 = require(\"./featureDetection\");\n\nclass StreamArrayParser extends stream_1.Transform {\n  /**\n   * StreamArrayParser processes array of valid JSON objects in random chunks\n   * through readable stream, and produces a stream of plain Javascript objects\n   * where it converted from the corresponding protobuf message instance.\n   *\n   * The default JSON parser decodes the input stream under the\n   * following rules:\n   *  1. The stream represents a valid JSON array (must start with a \"[\" and\n   * close with the corresponding \"]\"). Each element of this array is assumed to\n   * be either an array or an object, and will be decoded as a JS object and\n   *    delivered.\n   *  2. All JSON elements in the buffer will be decoded and delivered in a\n   * stream.\n   *\n   * @private\n   * @constructor\n   * @param {protobuf.Method} rpc - the protobuf method produce array of JSON.\n   * @param {Object} options - the options pass to Transform Stream. See more\n   * details\n   * https://nodejs.org/api/stream.html#stream_new_stream_transform_options.\n   */\n  constructor(rpc, options) {\n    super(Object.assign({}, options, {\n      readableObjectMode: true\n    }));\n    this._done = false;\n    this._prevBlock = Buffer.from('');\n    this._isInString = false;\n    this._isSkipped = false;\n    this._level = 0;\n    this.rpc = rpc;\n    this.cancelController = featureDetection_1.hasAbortController() ? // eslint-disable-next-line no-undef\n    new AbortController() : new abort_controller_1.AbortController();\n    this.cancelSignal = this.cancelController.signal;\n    this.cancelRequested = false;\n  }\n\n  _transform(chunk, _, callback) {\n    let objectStart = 0;\n    let curIndex = 0;\n\n    if (this._level === 0 && curIndex === 0) {\n      if (String.fromCharCode(chunk[0]) !== '[') {\n        this.emit('error', new Error(`Internal Error: API service stream data must start with a '[' and close with the corresponding ']', but it start with ${String.fromCharCode(chunk[0])}`));\n      }\n\n      curIndex++;\n      this._level++;\n    }\n\n    while (curIndex < chunk.length) {\n      const curValue = String.fromCharCode(chunk[curIndex]);\n\n      if (!this._isSkipped) {\n        switch (curValue) {\n          case '{':\n            // Check if it's in string, we ignore the curly brace in string.\n            // Otherwise the object level++.\n            if (!this._isInString) {\n              this._level++;\n            }\n\n            if (!this._isInString && this._level === 2) {\n              objectStart = curIndex;\n            }\n\n            break;\n\n          case '\"':\n            // Flip the string status\n            this._isInString = !this._isInString;\n            break;\n\n          case '}':\n            // check if it's in string\n            // if true, do nothing\n            // if false and level = 0, push data\n            if (!this._isInString) {\n              this._level--;\n            }\n\n            if (!this._isInString && this._level === 1) {\n              // find a object\n              const objBuff = Buffer.concat([this._prevBlock, chunk.slice(objectStart, curIndex + 1)]);\n\n              try {\n                // HTTP reponse.ok is true.\n                const msgObj = fallbackRest_1.decodeResponse(this.rpc, true, objBuff);\n                this.push(msgObj);\n              } catch (err) {\n                this.emit('error', err);\n              }\n\n              objectStart = curIndex + 1;\n              this._prevBlock = Buffer.from('');\n            }\n\n            break;\n\n          case ']':\n            if (!this._isInString && this._level === 1) {\n              this._done = true;\n              this.push(null);\n            }\n\n            break;\n\n          case '\\\\':\n            // Escaping escape character.\n            this._isSkipped = true;\n            break;\n\n          default:\n            break;\n        }\n      } else {\n        this._isSkipped = false;\n      }\n\n      curIndex++;\n    }\n\n    if (this._level > 1) {\n      this._prevBlock = Buffer.concat([this._prevBlock, chunk.slice(objectStart, curIndex)]);\n    }\n\n    callback();\n  }\n\n  _flush(callback) {\n    callback();\n  }\n\n  cancel() {\n    this._done = true;\n    this.cancelRequested = true;\n    this.cancelController.abort();\n    this.end();\n  }\n\n}\n\nexports.StreamArrayParser = StreamArrayParser;","map":{"version":3,"mappings":"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","names":["StreamArrayParser","stream_1","constructor","rpc","options","Object","assign","readableObjectMode","_done","_prevBlock","Buffer","from","_isInString","_isSkipped","_level","cancelController","featureDetection_1","AbortController","abort_controller_1","cancelSignal","signal","cancelRequested","_transform","chunk","_","callback","objectStart","curIndex","String","fromCharCode","emit","Error","length","curValue","objBuff","concat","slice","msgObj","fallbackRest_1","push","err","_flush","cancel","abort","end","exports"],"sources":["../../src/streamArrayParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}