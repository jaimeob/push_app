{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\n\nclass PathTemplate {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  match(path) {\n    let pathSegments = path.split('/');\n    const bindings = {};\n\n    if (pathSegments.length !== this.segments.length) {\n      // if the path contains a wildcard, then the length may differ by 1.\n      if (!this.data.includes('**')) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n      } else if (pathSegments.length !== this.segments.length + 1) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n      }\n    }\n\n    for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n      if (this.segments[index] !== pathSegments[0]) {\n        if (!this.segments[index].includes('*')) {\n          throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n        } else {\n          let segment = this.segments[index];\n          const matches = segment.match(/\\{[$0-9a-zA-Z_]+=.*?\\}/g);\n\n          if (!matches) {\n            throw new Error(`Error processing path template segment ${segment}`);\n          }\n\n          const variables = matches.map(str => str.replace(/^\\{/, '').replace(/=.*/, ''));\n\n          if (segment.includes('**')) {\n            bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\n            pathSegments = pathSegments.slice(2);\n          } else {\n            // atomic resource\n            if (variables.length === 1) {\n              bindings[variables[0]] = pathSegments[0];\n            } else {\n              // non-slash resource\n              // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n              // split the match pathSegments[0] -> value: ['bar', 'user2']\n              // compare the length of two arrays, and compare array items\n              const value = pathSegments[0].split(/[-_.~]/);\n\n              if (value.length !== variables.length) {\n                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n              }\n\n              for (const v of variables) {\n                bindings[v] = value[0];\n                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                value.shift();\n              } // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n\n\n              if (segment !== pathSegments[0]) {\n                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n              }\n            }\n\n            pathSegments.shift();\n          }\n        }\n      } else {\n        pathSegments.shift();\n      }\n    }\n\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n\n\n  render(bindings) {\n    if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n      throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n    }\n\n    let path = this.inspect();\n\n    for (const key of Object.keys(bindings)) {\n      const b = bindings[key].toString();\n\n      if (!this.bindings[key]) {\n        throw new TypeError(`render fails for not matching ${bindings[key]}`);\n      }\n\n      const variable = this.bindings[key];\n\n      if (variable === '*') {\n        if (!b.match(/[^/{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=*}`, `${b}`);\n      } else if (variable === '**') {\n        if (!b.match(/[^{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=**}`, `${b}`);\n      }\n    }\n\n    return path;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n\n\n  inspect() {\n    return this.segments.join('/');\n  }\n  /**\n   * Parse the path template.\n   *\n   * @return {string[]} return segments of the input path.\n   * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n   */\n\n\n  parsePathTemplate(data) {\n    const pathSegments = splitPathTemplate(data);\n    let index = 0;\n    let wildCardCount = 0;\n    const segments = [];\n    let matches;\n    pathSegments.forEach(segment => {\n      // * or ** -> segments.push('{$0=*}');\n      //         -> bindings['$0'] = '*'\n      if (segment === '*' || segment === '**') {\n        this.bindings[`$${index}`] = segment;\n        segments.push(`{$${index}=${segment}}`);\n        index = index + 1;\n\n        if (segment === '**') {\n          ++wildCardCount;\n        }\n      } else if (matches = segment.match(/\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\}/g)) {\n        for (const subsegment of matches) {\n          const pairMatch = subsegment.match(/^\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\}$/);\n\n          if (!pairMatch) {\n            throw new Error(`Cannot process path template segment ${subsegment}`);\n          }\n\n          const key = pairMatch[1];\n          let value = pairMatch[2];\n\n          if (!value) {\n            value = '*';\n            segment = segment.replace(key, key + '=*');\n            this.bindings[key] = value;\n          } else if (value === '*') {\n            this.bindings[key] = value;\n          } else if (value === '**') {\n            ++wildCardCount;\n            this.bindings[key] = value;\n          }\n        }\n\n        segments.push(segment);\n      } else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n        segments.push(segment);\n      }\n    });\n\n    if (wildCardCount > 1) {\n      throw new TypeError('Can not have more than one wildcard.');\n    }\n\n    return segments;\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\n\nfunction splitPathTemplate(data) {\n  let left = 0;\n  let right = 0;\n  let bracketCount = 0;\n  const segments = [];\n\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n\n      segments.push(data.substring(left));\n    }\n\n    right = right + 1;\n  }\n\n  return segments;\n}","map":{"version":3,"mappings":"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","names":["PathTemplate","constructor","data","segments","parsePathTemplate","size","length","match","path","pathSegments","split","bindings","includes","TypeError","index","segment","matches","Error","variables","map","str","replace","slice","value","v","shift","render","Object","keys","inspect","key","b","toString","variable","join","splitPathTemplate","wildCardCount","forEach","push","subsegment","pairMatch","exports","left","right","bracketCount","charAt","substring"],"sources":["../../src/pathTemplate.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}