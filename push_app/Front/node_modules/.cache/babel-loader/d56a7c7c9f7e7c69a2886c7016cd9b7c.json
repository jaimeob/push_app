{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst StreamSearch = require('streamsearch');\n\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n');\nconst RE_CRLF = /\\r\\n/g; // eslint-disable-next-line no-control-regex\n\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/;\nconst MAX_HEADER_PAIRS = 2000; // From node's http.js\n\nconst MAX_HEADER_SIZE = 80 * 1024; // From node's http_parser\n\nclass HeaderParser extends EventEmitter {\n  constructor(cfg) {\n    super();\n    this.nread = 0;\n    this.maxed = false;\n    this.npairs = 0;\n    this.maxHeaderPairs = cfg && typeof cfg.maxHeaderPairs === 'number' ? cfg.maxHeaderPairs : MAX_HEADER_PAIRS;\n    this.buffer = '';\n    this.header = {};\n    this.finished = false;\n    this.ss = new StreamSearch(B_DCRLF, (isMatch, data, start, end) => {\n      if (data && !this.maxed) {\n        if (this.nread + (end - start) > MAX_HEADER_SIZE) {\n          end = MAX_HEADER_SIZE - this.nread;\n          this.nread = MAX_HEADER_SIZE;\n        } else {\n          this.nread += end - start;\n        }\n\n        if (this.nread === MAX_HEADER_SIZE) this.maxed = true;\n        this.buffer += data.toString('latin1', start, end);\n      }\n\n      if (isMatch) this._finish();\n    });\n  }\n\n  push(data) {\n    const r = this.ss.push(data);\n    if (this.finished) return r;\n  }\n\n  reset() {\n    this.finished = false;\n    this.buffer = '';\n    this.header = {};\n    this.ss.reset();\n  }\n\n  _finish() {\n    let hadError = false;\n    if (this.buffer) hadError = !parseHeader(this);\n    this.ss.matches = this.ss.maxMatches;\n    const header = this.header;\n    this.header = {};\n    this.buffer = '';\n    this.finished = true;\n    this.nread = this.npairs = 0;\n    this.maxed = false;\n    if (!hadError) this.emit('header', header);\n  }\n\n}\n\nfunction parseHeader(self) {\n  if (self.npairs === self.maxHeaderPairs) return true;\n  const lines = self.buffer.split(RE_CRLF);\n  const len = lines.length;\n  let m;\n  let h;\n  let modded = false;\n\n  for (let i = 0; i < len; ++i) {\n    if (lines[i].length === 0) continue;\n\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // Folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      if (!h) {\n        self.emit('error', new Error('Unexpected folded header value'));\n        return false;\n      }\n\n      self.header[h][self.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n\n      if (m) {\n        h = m[1].toLowerCase();\n\n        if (m[2]) {\n          if (self.header[h] === undefined) self.header[h] = [m[2]];else self.header[h].push(m[2]);\n        } else {\n          self.header[h] = [''];\n        }\n\n        if (++self.npairs === self.maxHeaderPairs) break;\n      } else {\n        self.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n\n  if (!modded) self.buffer = '';\n  return true;\n}\n\nmodule.exports = HeaderParser;","map":{"version":3,"sources":["/Users/jaimeojeda/Documents/firebase/push_app/node_modules/dicer/lib/HeaderParser.js"],"names":["EventEmitter","require","StreamSearch","B_DCRLF","Buffer","from","RE_CRLF","RE_HDR","MAX_HEADER_PAIRS","MAX_HEADER_SIZE","HeaderParser","constructor","cfg","nread","maxed","npairs","maxHeaderPairs","buffer","header","finished","ss","isMatch","data","start","end","toString","_finish","push","r","reset","hadError","parseHeader","matches","maxMatches","emit","self","lines","split","len","length","m","h","modded","i","Error","exec","toLowerCase","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\n\nconst StreamSearch = require('streamsearch');\n\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n');\nconst RE_CRLF = /\\r\\n/g;\n// eslint-disable-next-line no-control-regex\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/;\nconst MAX_HEADER_PAIRS = 2000; // From node's http.js\nconst MAX_HEADER_SIZE = 80 * 1024; // From node's http_parser\n\nclass HeaderParser extends EventEmitter {\n  constructor(cfg) {\n    super();\n\n    this.nread = 0;\n    this.maxed = false;\n    this.npairs = 0;\n    this.maxHeaderPairs = (cfg && typeof cfg.maxHeaderPairs === 'number'\n                           ? cfg.maxHeaderPairs\n                           : MAX_HEADER_PAIRS);\n    this.buffer = '';\n    this.header = {};\n    this.finished = false;\n    this.ss = new StreamSearch(B_DCRLF, (isMatch, data, start, end) => {\n      if (data && !this.maxed) {\n        if (this.nread + (end - start) > MAX_HEADER_SIZE) {\n          end = (MAX_HEADER_SIZE - this.nread);\n          this.nread = MAX_HEADER_SIZE;\n        } else {\n          this.nread += (end - start);\n        }\n\n        if (this.nread === MAX_HEADER_SIZE)\n          this.maxed = true;\n\n        this.buffer += data.toString('latin1', start, end);\n      }\n      if (isMatch)\n        this._finish();\n    });\n  }\n\n  push(data) {\n    const r = this.ss.push(data);\n    if (this.finished)\n      return r;\n  }\n\n  reset() {\n    this.finished = false;\n    this.buffer = '';\n    this.header = {};\n    this.ss.reset();\n  }\n\n  _finish() {\n    let hadError = false;\n    if (this.buffer)\n      hadError = !parseHeader(this);\n    this.ss.matches = this.ss.maxMatches;\n    const header = this.header;\n    this.header = {};\n    this.buffer = '';\n    this.finished = true;\n    this.nread = this.npairs = 0;\n    this.maxed = false;\n    if (!hadError)\n      this.emit('header', header);\n  }\n}\n\nfunction parseHeader(self) {\n  if (self.npairs === self.maxHeaderPairs)\n    return true;\n\n  const lines = self.buffer.split(RE_CRLF);\n  const len = lines.length;\n  let m;\n  let h;\n  let modded = false;\n\n  for (let i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      continue;\n\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // Folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      if (!h) {\n        self.emit('error', new Error('Unexpected folded header value'));\n        return false;\n      }\n      self.header[h][self.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase();\n        if (m[2]) {\n          if (self.header[h] === undefined)\n            self.header[h] = [m[2]];\n          else\n            self.header[h].push(m[2]);\n        } else {\n          self.header[h] = [''];\n        }\n        if (++self.npairs === self.maxHeaderPairs)\n          break;\n      } else {\n        self.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n  if (!modded)\n    self.buffer = '';\n\n  return true;\n}\n\nmodule.exports = HeaderParser;\n"]},"metadata":{},"sourceType":"script"}