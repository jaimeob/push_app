{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n\n/* global AbortController */\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst featureDetection_1 = require(\"./featureDetection\");\n\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\n\nconst stream_1 = require(\"stream\");\n\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n  const fetch = featureDetection_1.hasWindowFetch() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      const cancelController = featureDetection_1.hasAbortController() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: { ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n\n        if (fetchParameters.method === 'get' || fetchParameters.method === 'delete') {\n          delete fetchRequest['body'];\n        }\n\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          stream_1.pipeline(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(_ref => {\n            let [ok, buffer] = _ref;\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              callback(err);\n            }\n          });\n        }\n      });\n\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n\n  return serviceStub;\n}\n\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"mappings":"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","names":["generateServiceStub","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","fetch","featureDetection_1","window","node_fetch_1","serviceStub","close","cancel","rpcName","rpc","Object","entries","request","options","_metadata","callback","cancelController","AbortController","abort_controller_1","cancelSignal","signal","cancelRequested","fetchParameters","url","headers","key","keys","streamArrayParser","streamArrayParser_1","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","stream_1","err","Error","name","emit","Promise","all","resolve","arrayBuffer","buffer","catch","abort","exports"],"sources":["../../src/fallbackServiceStub.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}