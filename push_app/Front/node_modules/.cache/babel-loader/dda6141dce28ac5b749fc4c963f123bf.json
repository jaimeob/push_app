{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OngoingCallPromise = exports.OngoingCall = void 0;\n\nconst status_1 = require(\"./status\");\n\nconst googleError_1 = require(\"./googleError\");\n\nclass OngoingCall {\n  /**\n   * OngoingCall manages callback, API calls, and cancellation\n   * of the API calls.\n   * @param {APICallback=} callback\n   *   The callback to be called asynchronously when the API call\n   *   finishes.\n   * @constructor\n   * @property {APICallback} callback\n   *   The callback function to be called.\n   * @private\n   */\n  constructor(callback) {\n    this.callback = callback;\n    this.completed = false;\n  }\n  /**\n   * Cancels the ongoing promise.\n   */\n\n\n  cancel() {\n    if (this.completed) {\n      return;\n    }\n\n    this.completed = true;\n\n    if (this.cancelFunc) {\n      this.cancelFunc();\n    } else {\n      const error = new googleError_1.GoogleError('cancelled');\n      error.code = status_1.Status.CANCELLED;\n      this.callback(error);\n    }\n  }\n  /**\n   * Call calls the specified function. Result will be used to fulfill\n   * the promise.\n   *\n   * @param {SimpleCallbackFunction} func\n   *   A function for an API call.\n   * @param {Object} argument\n   *   A request object.\n   */\n\n\n  call(func, argument) {\n    if (this.completed) {\n      return;\n    }\n\n    const canceller = func(argument, (err, response, next, rawResponse) => {\n      this.completed = true;\n      setImmediate(this.callback, err, response, next, rawResponse);\n    });\n\n    if (canceller instanceof Promise) {\n      canceller.catch(err => {\n        setImmediate(this.callback, new googleError_1.GoogleError(err), null, null, null);\n      });\n    }\n\n    this.cancelFunc = () => canceller.cancel();\n  }\n\n}\n\nexports.OngoingCall = OngoingCall;\n\nclass OngoingCallPromise extends OngoingCall {\n  /**\n   * GaxPromise is GRPCCallbackWrapper, but it holds a promise when\n   * the API call finishes.\n   * @constructor\n   * @private\n   */\n  constructor() {\n    let resolveCallback;\n    let rejectCallback;\n\n    const callback = (err, response, next, rawResponse) => {\n      if (err) {\n        // If gRPC metadata exist, parsed google.rpc.status details.\n        if (err.metadata) {\n          rejectCallback(googleError_1.GoogleError.parseGRPCStatusDetails(err));\n        } else {\n          rejectCallback(err);\n        }\n      } else if (response !== undefined) {\n        resolveCallback([response, next || null, rawResponse || null]);\n      } else {\n        throw new googleError_1.GoogleError('Neither error nor response are defined');\n      }\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    super(callback);\n    this.promise = promise;\n\n    this.promise.cancel = () => {\n      this.cancel();\n    };\n  }\n\n}\n\nexports.OngoingCallPromise = OngoingCallPromise;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAgBA;;AAWA;;AAEA,MAAaA,WAAb,CAAwB;AAKtB;;;;;;;;;;;AAWAC,cAAYC,QAAZ,EAAiC;AAC/B,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACD;AAED;;;;;AAGAC,QAAM;AACJ,QAAI,KAAKD,SAAT,EAAoB;AAClB;AACD;;AACD,SAAKA,SAAL,GAAiB,IAAjB;;AACA,QAAI,KAAKE,UAAT,EAAqB;AACnB,WAAKA,UAAL;AACD,KAFD,MAEO;AACL,YAAMC,KAAK,GAAG,IAAIC,yBAAJ,CAAgB,WAAhB,CAAd;AACAD,WAAK,CAACE,IAAN,GAAaC,gBAAOC,SAApB;AACA,WAAKR,QAAL,CAAeI,KAAf;AACD;AACF;AAED;;;;;;;;;;;AASAK,MAAI,CAACC,IAAD,EAA+BC,QAA/B,EAAoD;AACtD,QAAI,KAAKV,SAAT,EAAoB;AAClB;AACD;;AACD,UAAMW,SAAS,GAAGF,IAAI,CACpBC,QADoB,EAEpB,CACEE,GADF,EAEEC,QAFF,EAGEC,IAHF,EAIEC,WAJF,KAKI;AACF,WAAKf,SAAL,GAAiB,IAAjB;AACAgB,kBAAY,CAAC,KAAKjB,QAAN,EAAiBa,GAAjB,EAAsBC,QAAtB,EAAgCC,IAAhC,EAAsCC,WAAtC,CAAZ;AACD,KAVmB,CAAtB;;AAYA,QAAIJ,SAAS,YAAYM,OAAzB,EAAkC;AAChCN,eAAS,CAACO,KAAV,CAAgBN,GAAG,IAAG;AACpBI,oBAAY,CAAC,KAAKjB,QAAN,EAAiB,IAAIK,yBAAJ,CAAgBQ,GAAhB,CAAjB,EAAuC,IAAvC,EAA6C,IAA7C,EAAmD,IAAnD,CAAZ;AACD,OAFD;AAGD;;AACD,SAAKV,UAAL,GAAkB,MAAMS,SAAS,CAACV,MAAV,EAAxB;AACD;;AArEqB;;AAAxBkB;;AA4EA,MAAaC,kBAAb,SAAwCvB,WAAxC,CAAmD;AAEjD;;;;;;AAMAC;AACE,QAAIuB,eAAJ;AAGA,QAAIC,cAAJ;;AACA,UAAMvB,QAAQ,GAAgB,CAC5Ba,GAD4B,EAE5BC,QAF4B,EAG5BC,IAH4B,EAI5BC,WAJ4B,KAK1B;AACF,UAAIH,GAAJ,EAAS;AACP;AACA,YAAIA,GAAG,CAACW,QAAR,EAAkB;AAChBD,wBAAc,CAAClB,0BAAYoB,sBAAZ,CAAmCZ,GAAnC,CAAD,CAAd;AACD,SAFD,MAEO;AACLU,wBAAc,CAACV,GAAD,CAAd;AACD;AACF,OAPD,MAOO,IAAIC,QAAQ,KAAKY,SAAjB,EAA4B;AACjCJ,uBAAe,CAAC,CAACR,QAAD,EAAWC,IAAI,IAAI,IAAnB,EAAyBC,WAAW,IAAI,IAAxC,CAAD,CAAf;AACD,OAFM,MAEA;AACL,cAAM,IAAIX,yBAAJ,CAAgB,wCAAhB,CAAN;AACD;AACF,KAlBD;;AAmBA,UAAMsB,OAAO,GAAG,IAAIT,OAAJ,CAAY,CAACU,OAAD,EAAUC,MAAV,KAAoB;AAC9CP,qBAAe,GAAGM,OAAlB;AACAL,oBAAc,GAAGM,MAAjB;AACD,KAHe,CAAhB;AAIA,UAAM7B,QAAN;AACA,SAAK2B,OAAL,GAAeA,OAAf;;AACA,SAAKA,OAAL,CAAazB,MAAb,GAAsB,MAAK;AACzB,WAAKA,MAAL;AACD,KAFD;AAGD;;AAzCgD;;AAAnDkB","names":["OngoingCall","constructor","callback","completed","cancel","cancelFunc","error","googleError_1","code","status_1","CANCELLED","call","func","argument","canceller","err","response","next","rawResponse","setImmediate","Promise","catch","exports","OngoingCallPromise","resolveCallback","rejectCallback","metadata","parseGRPCStatusDetails","undefined","promise","resolve","reject"],"sources":["../../src/call.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}