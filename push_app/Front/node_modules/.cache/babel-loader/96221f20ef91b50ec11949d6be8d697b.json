{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst warnings_1 = require(\"../warnings\");\n\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\n\nconst task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\n\n\nclass BundleExecutor {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  constructor(bundleOptions, bundleDescriptor) {\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  schedule(apiCall, request, callback) {\n    const bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n    callback = callback || noop;\n\n    if (bundleId === undefined) {\n      warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + `Invoking immediately. Request: ${JSON.stringify(request)} ` + `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n      return apiCall(request, callback);\n    }\n\n    if (request[this._descriptor.bundledField] === undefined) {\n      warnings_1.warn('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` + `Invoking immediately. Request: ${JSON.stringify(request)}`);\n      return apiCall(request, callback);\n    }\n\n    if (!(bundleId in this._tasks)) {\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n    }\n\n    let task = this._tasks[bundleId];\n    callback.id = String(this._invocationId++);\n    this._invocations[callback.id] = bundleId;\n    const bundledField = request[this._descriptor.bundledField];\n    const elementCount = bundledField.length;\n    let requestBytes = 0; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const self = this;\n    bundledField.forEach(obj => {\n      requestBytes += this._descriptor.byteLengthFunction(obj);\n    });\n    const countLimit = this._options.elementCountLimit || 0;\n    const byteLimit = this._options.requestByteLimit || 0;\n\n    if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n      let message;\n\n      if (countLimit > 0 && elementCount > countLimit) {\n        message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n      } else {\n        message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n      }\n\n      const error = new googleError_1.GoogleError(message);\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n      return {\n        cancel: noop\n      };\n    }\n\n    const existingCount = task.getElementCount();\n    const existingBytes = task.getRequestByteSize();\n\n    if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n      this._runNow(bundleId);\n\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      task = this._tasks[bundleId];\n    }\n\n    task.extend(bundledField, requestBytes, callback);\n    const ret = {\n      cancel() {\n        self._cancel(callback.id);\n      }\n\n    };\n    const countThreshold = this._options.elementCountThreshold || 0;\n    const sizeThreshold = this._options.requestByteThreshold || 0;\n\n    if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n      this._runNow(bundleId);\n\n      return ret;\n    }\n\n    if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n      this._timers[bundleId] = setTimeout(() => {\n        delete this._timers[bundleId];\n\n        this._runNow(bundleId);\n      }, this._options.delayThreshold);\n    }\n\n    return ret;\n  }\n  /**\n   * Clears scheduled timeout if it exists.\n   *\n   * @param {String} bundleId - the id for the task whose timeout needs to be\n   *   cleared.\n   * @private\n   */\n\n\n  _maybeClearTimeout(bundleId) {\n    if (bundleId in this._timers) {\n      const timerId = this._timers[bundleId];\n      delete this._timers[bundleId];\n      clearTimeout(timerId);\n    }\n  }\n  /**\n   * Cancels an event.\n   *\n   * @param {String} id - The id for the event in the task.\n   * @private\n   */\n\n\n  _cancel(id) {\n    if (!(id in this._invocations)) {\n      return;\n    }\n\n    const bundleId = this._invocations[id];\n\n    if (!(bundleId in this._tasks)) {\n      return;\n    }\n\n    const task = this._tasks[bundleId];\n    delete this._invocations[id];\n\n    if (task.cancel(id)) {\n      this._maybeClearTimeout(bundleId);\n\n      delete this._tasks[bundleId];\n    }\n  }\n  /**\n   * Invokes a task.\n   *\n   * @param {String} bundleId - The id for the task.\n   * @private\n   */\n\n\n  _runNow(bundleId) {\n    if (!(bundleId in this._tasks)) {\n      warnings_1.warn('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n      return;\n    }\n\n    this._maybeClearTimeout(bundleId);\n\n    const task = this._tasks[bundleId];\n    delete this._tasks[bundleId];\n    task.run().forEach(id => {\n      delete this._invocations[id];\n    });\n  }\n\n}\n\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"mappings":"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","names":["noop","BundleExecutor","constructor","bundleOptions","bundleDescriptor","_options","_descriptor","_tasks","_timers","_invocations","_invocationId","schedule","apiCall","request","callback","bundleId","bundlingUtils_1","requestDiscriminatorFields","undefined","warnings_1","JSON","stringify","bundledField","task_1","subresponseField","task","id","String","elementCount","length","requestBytes","self","forEach","obj","byteLengthFunction","countLimit","elementCountLimit","byteLimit","requestByteLimit","message","error","googleError_1","code","status_1","INVALID_ARGUMENT","cancel","existingCount","getElementCount","existingBytes","getRequestByteSize","_runNow","extend","ret","_cancel","countThreshold","elementCountThreshold","sizeThreshold","requestByteThreshold","delayThreshold","setTimeout","_maybeClearTimeout","timerId","clearTimeout","run","exports"],"sources":["../../../src/bundlingCalls/bundleExecutor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}