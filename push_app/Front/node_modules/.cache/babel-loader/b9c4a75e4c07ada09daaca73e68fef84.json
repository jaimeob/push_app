{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = __importDefault(require(\"net\"));\n\nconst tls_1 = __importDefault(require(\"tls\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst agent_base_1 = require(\"agent-base\");\n\nconst debug = (0, debug_1.default)('http-proxy-agent');\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n/**\n * The `HttpProxyAgent` implements an HTTP Agent subclass that connects\n * to the specified \"HTTP proxy server\" in order to proxy HTTP requests.\n *\n * @api public\n */\n\n\nclass HttpProxyAgent extends agent_base_1.Agent {\n  constructor(_opts) {\n    let opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('Creating new HttpProxyAgent instance: %o', opts);\n    super(opts);\n    const proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = this.secureProxy ? 443 : 80;\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    this.proxy = proxy;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  callback(req, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        proxy,\n        secureProxy\n      } = this;\n      const parsed = url_1.default.parse(req.path);\n\n      if (!parsed.protocol) {\n        parsed.protocol = 'http:';\n      }\n\n      if (!parsed.hostname) {\n        parsed.hostname = opts.hostname || opts.host || null;\n      }\n\n      if (parsed.port == null && typeof opts.port) {\n        parsed.port = String(opts.port);\n      }\n\n      if (parsed.port === '80') {\n        // if port is 80, then we can remove the port so that the\n        // \":80\" portion is not on the produced URL\n        parsed.port = '';\n      } // Change the `http.ClientRequest` instance's \"path\" field\n      // to the absolute path of the URL that will be requested.\n\n\n      req.path = url_1.default.format(parsed); // Inject the `Proxy-Authorization` header if necessary.\n\n      if (proxy.auth) {\n        req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);\n      } // Create a socket connection to the proxy server.\n\n\n      let socket;\n\n      if (secureProxy) {\n        debug('Creating `tls.Socket`: %o', proxy);\n        socket = tls_1.default.connect(proxy);\n      } else {\n        debug('Creating `net.Socket`: %o', proxy);\n        socket = net_1.default.connect(proxy);\n      } // At this point, the http ClientRequest's internal `_header` field\n      // might have already been set. If this is the case then we'll need\n      // to re-generate the string since we just changed the `req.path`.\n\n\n      if (req._header) {\n        let first;\n        let endOfHeaders;\n        debug('Regenerating stored HTTP header string for request');\n        req._header = null;\n\n        req._implicitHeader();\n\n        if (req.output && req.output.length > 0) {\n          // Node < 12\n          debug('Patching connection write() output buffer with updated header');\n          first = req.output[0];\n          endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n          req.output[0] = req._header + first.substring(endOfHeaders);\n          debug('Output buffer: %o', req.output);\n        } else if (req.outputData && req.outputData.length > 0) {\n          // Node >= 12\n          debug('Patching connection write() output buffer with updated header');\n          first = req.outputData[0].data;\n          endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n          req.outputData[0].data = req._header + first.substring(endOfHeaders);\n          debug('Output buffer: %o', req.outputData[0].data);\n        }\n      } // Wait for the socket's `connect` event, so that this `callback()`\n      // function throws instead of the `http` request machinery. This is\n      // important for i.e. `PacProxyAgent` which determines a failed proxy\n      // connection via the `callback()` function throwing.\n\n\n      yield (0, once_1.default)(socket, 'connect');\n      return socket;\n    });\n  }\n\n}\n\nexports.default = HttpProxyAgent;","map":{"version":3,"mappings":"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","names":["debug","isHTTPS","protocol","test","HttpProxyAgent","agent_base_1","constructor","_opts","opts","url_1","parse","Error","proxy","secureProxy","host","hostname","port","parseInt","path","pathname","callback","req","parsed","String","format","auth","setHeader","Buffer","from","toString","socket","tls_1","connect","net_1","_header","first","endOfHeaders","_implicitHeader","output","length","indexOf","substring","outputData","data","exports"],"sources":["../src/agent.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}